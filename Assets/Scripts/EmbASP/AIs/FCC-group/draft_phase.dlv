% ====================================================================
%                           DRAFT PHASE
% ====================================================================





troops_from_cards(T,Player,Troops):-
    possible_card_exchange(T, Player, ExchangeId, _, _, _, _, Troops),
    exchange_cards(T, Player, ExchangeId).

has_exchanged_cards(T, Player):- exchange_cards(T, Player, ExchangeId).

troops_from_cards(T,Player,0):-
    curr_turn(T, Player), not has_exchanged_cards(T, Player).

troops_to_place_with_cards(T, Player, MaxTroops):-
    troops_to_place(T, Player, Troops),
    troops_from_cards(T,Player,Card_Troops),
    MaxTroops = Troops + Card_Troops.

troops(0).
troops(Troops) :- 
    troops_to_place_with_cards(T, Player, MaxTroops),
    curr_turn(T,P), 
    troops(Troops1),
    MaxTroops>10,
    MaxTroops<20,
    Troops=Troops1+1, 
    Troops<=MaxTroops/2.

troops(Troops) :- 
    troops_to_place_with_cards(T, Player, MaxTroops),
    curr_turn(T,P), 
    troops(Troops1),
    MaxTroops>=20,
    Troops=Troops1+1, 
    Troops<=MaxTroops/3+2.

troops(Troops) :- 
    troops_to_place_with_cards(T, Player, MaxTroops),
    curr_turn(T,P), 
    troops(Troops1), 
    MaxTroops<= 10,
    Troops=Troops1+1, 
    Troops<=MaxTroops.

%%%% BUG TO BE FIXED, OVERFLOW ON RANGE BOUNDS.


min_troops_to_place(T, Player, MinTroops) :- 
    troops_to_place_with_cards(T, Player, MaxTroops),
    min_troops_to_place_divider(MTTPD),
    MaxTroops <25,
    MinTroops = MaxTroops / MTTPD.

max_place_count(3).

fronteer_territory_count(T, Player, Count):- 
    curr_turn(T, Player),
    #count{Territory : fronteer_territory(T, Territory, Player)} = Count.

min_troops_to_place(T, Player, MinTroops) :- 
    troops_to_place_with_cards(T, Player, MaxTroops),
    min_troops_to_place_divider(MTTPD),
    MaxTroops >=25,
    #min{Count : fronteer_territory_count(T, Player, Count); X: max_place_count(X)} = Div,
    MinTroops = MaxTroops / Div.



{ place(T, Player, Territory, Troops) : 
    fronteer_territory(T, Territory, Player) } <= 1 :- 
    curr_turn(T,Player),
    troops(Troops), 
    min_troops_to_place(T, Player, MinTroops),
    Troops >= MinTroops,
    Troops > 0.

:- place(T, P, Territory, N1), place(T, P, Territory, N2), N1!=N2.


placed_troops(T, Player, Troops) :- 
    curr_turn(T, Player), 
    Troops = #sum{N,Terr : place(T,Player,Terr,N)}.

:- troops_to_place_with_cards(T,P,Troops), not placed_troops(T, P, Troops).

% al territorio T, quanti vicini amici ha? FATTO
% al territorio T, quanti vicini nemici ha? FATTO
% al territorio T, quante truppe nemiche vicine ha?
% il territorio T Ã¨ un territorio di confine?
% il territorio T p un territorio di confine di un continente C?
    % quanti territori mancano a P per completare il continente C (confinante con T)?

% quanti territori mancano a P per conquistare il continente C?
% quanti territori mancano a P per conquistare il mondo?

% differenza di truppe 

%quanto migliora la condizione di un paese piazzandogli delle truppe?


territory_welfare_index(T, Territory, Index) :- 
    territory_control(T, Territory, Player, Troops),
    fronteer_territory(T, Territory, Player), 
    curr_turn(T, Player),
    adjacent_enemy_troops(T, Territory, PlayerOwner, Enemies),
    Index = Troops - Enemies.

%
territory_welfare_index_projection(T, Territory, Value) :- 
    territory_welfare_index(T, Territory, Index),
    territory_index_strong_weight(W), 
    curr_turn(T, Player),
    place(T, Player, Territory, Troops),
    Index + Troops > 2,
    Index + Troops < 5, 
    Value = (Index + Troops) * W * (Index).


territory_welfare_index_projection(T, Territory, Value) :- 
    territory_welfare_index(T, Territory, Index),
    territory_index_weak_weight(W), 
    curr_turn(T, Player),
    place(T, Player, Territory, Troops),
    Index + Troops > 4, 
    Value = (Index + Troops) * W * (Index).

territory_welfare_index_projection(T, Territory, Value) :- 
    territory_welfare_index(T, Territory, Index),
    territory_index_medium_weight(W), 
    curr_turn(T, Player),
    place(T, Player, Territory, Troops),
    Index + Troops >= 0,
    Index + Troops < 3, 
    Value = (Index + Troops) * W * (Index).

territory_welfare_index_projection(T, Territory, Value) :- 
    territory_welfare_index(T, Territory, Index),
    territory_index_bad_weight(W), 
    curr_turn(T, Player),
    place(T, Player, Territory, Troops),
    Index + Troops < 0, 
    Value = (Index + Troops) * W * (Index).



% island_welfare_index(T, Id, Index) :- 
%     curr_turn(T, Player), 
%     island_id(T, Id, Player),
%     #sum{Value, Territory : territory_welfare_index_projection(T, Territory, Value)} = Index.


% :~ island_welfare_index(T, Id, Index), Val = -Index. [Val@3, Id]

:~ territory_welfare_index_projection(T, Territory, Value). [Value@3, Territory]
% ==================== AI DESIGN CONSTRAINTS ====================

% place troops only in fronteer territories (can't place in internal ones)
:- place(T, Player, Territory, _), territory_island_internal(T, _, Player, Territory).


% ----------- MAX PRIORITY -----------

% place troops preferring most valutable island
:~ place(T, Player, Territory, Troops), 
    territory_island(T, Id, Territory, Player),
    island_value_index(T, Id, Player, ValueIndex),
    Val = ValueIndex * 15.
    [Val@3, Territory]


:~ true. [5000@3]
% ----------- MID PRIORITY -----------



% prioritize territories where the difference between friendly and enemy troops is greater
% :~ place(T, Player, Territory, Troops), 
%    difference_troops_territory(T, Territory, PlayerOwner, Diff),
%    Cost = Diff + 100.
%    [Cost@2, Territory]


:-  curr_turn(T, Player),
    Count = #count{Territory : place(T, Player, Territory, _)}, Count > 7.


% massimizzare il numero di territori diversi in cui si fa draft

% :~ troops_to_place_with_cards(T, Player, MaxPlacesCount), 
%      drafts_count(T, Player, PlacesCount),
%      Cost = (MaxPlacesCount - PlacesCount) * 150.
%      [Cost@2, Cost]



draft(T, Territory, N) :- place(T, _, Territory, N).

% 1. isola
% 2. n_truppe + frontiera
